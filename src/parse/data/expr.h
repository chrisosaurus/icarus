#ifndef ICARUS_EXPRESSION_H
#define ICARUS_EXPRESSION_H

#include "../../data/pvector.h"
#include "../../data/symbol.h"
#include "../../lex/data/token.h"
#include "field.h"

struct ic_expr;

/* an application of a function
 */
struct ic_expr_func_call {
    /* ic_expr for function name */
    struct ic_expr *fname;

    /* a pointer vector of symbol(s) */
    struct ic_pvector type_symbols;

    /* this is a pvector of ic_expr *
     */
    struct ic_pvector args;

    /* string representation of function call
     * generated by ic_analyse_fcall_str
     * e.g. Foo(Int Int)
     */
    struct ic_string *string;

    /* the function we are calling
     * this is set at the analyse phase
     *
     * FIXME not currently used
     */
    struct ic_decl_func *fdecl;
};

/* allocate and initialise a new func call
 *
 * returns pointer on success
 * returns 0 on failure
 */
struct ic_expr_func_call *ic_expr_func_call_new(struct ic_expr *func_name);

/* intialise an existing func call
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_func_call_init(struct ic_expr_func_call *fcall, struct ic_expr *func_name);

/* destroy fcall
 *
 * only free fcall if `free_fcall` is truthy
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_func_call_destroy(struct ic_expr_func_call *fcall, unsigned int free_fcall);

/* set fdecl on fcall
 * must not already be set
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_func_call_set_fdecl(struct ic_expr_func_call *fcall, struct ic_decl_func *fdecl);

/* get fdecl on fcall
 * must already be set
 *
 * returns * on success
 * returns 0 on failure
 */
struct ic_decl_func *ic_expr_func_call_get_fdecl(struct ic_expr_func_call *fcall);

/* check if fdecl is already set
 *
 * returns 1 if fdecl is set
 * returns 0 otherwise
 */
unsigned int ic_expr_func_call_has_fdecl(struct ic_expr_func_call *fcall);

/* add a new argument to this function call
 *
 * returns 1 on success
 * returns 0 on failure
 */
int ic_expr_func_call_add_arg(struct ic_expr_func_call *fcall, struct ic_expr *expr);

/* get argument
 *
 * returns field at offset on success
 * returns 0 on failure
 */
struct ic_expr *ic_expr_func_call_get_arg(struct ic_expr_func_call *fcall, unsigned int i);

/* returns number of arguments on success
 * returns 0 on failure
 */
unsigned int ic_expr_func_call_length(struct ic_expr_func_call *fcall);

/* add a new type symbol to this function call
 *
 * returns 1 on success
 * returns 0 on failure
 */
int ic_expr_func_call_add_type_symbol(struct ic_expr_func_call *fcall, struct ic_symbol *type_symbol);

/* get type symbol
 *
 * returns field at offset on success
 * returns 0 on failure
 */
struct ic_symbol *ic_expr_func_call_get_type_symbol(struct ic_expr_func_call *fcall, unsigned int i);

/* returns number of type_symbols on success
 * returns 0 on failure
 */
unsigned int ic_expr_func_call_type_symbols_length(struct ic_expr_func_call *fcall);

/* get internal symbol for function name
 *
 * returns * on success
 * returns 0 on failure
 */
struct ic_symbol *ic_expr_func_call_get_symbol(struct ic_expr_func_call *fcall);

/* print this func call */
void ic_expr_func_call_print(FILE *fd, struct ic_expr_func_call *fcall, unsigned int *indent_level);

/* a use of an identifier (variable)
 */
struct ic_expr_identifier {
    struct ic_symbol identifier;
    unsigned int permissions;
};

/* allocate and initialise a new identifier
 *
 * returns pointer on success
 * returns 0 on failure
 */
struct ic_expr_identifier *ic_expr_identifier_new(char *id, unsigned int id_len, unsigned int permissions);

/* initialise an existing identifier
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_identifier_init(struct ic_expr_identifier *identifier, char *id, unsigned int id_len, unsigned int permissions);

/* destroy identifier
 *
 * will free id if `free_id` is truthy
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_identifier_destroy(struct ic_expr_identifier *identifier, unsigned int free_id);

/* get idenifier symbol
 *
 * returns ic_symbol * on success
 * returns 0 on error
 */
struct ic_symbol *ic_expr_identifier_symbol(struct ic_expr_identifier *identifier);

/* print this identifier */
void ic_expr_identifier_print(FILE *fd, struct ic_expr_identifier *identifier, unsigned int *indent_level);

enum ic_expr_constant_tag {
    ic_expr_constant_type_unsigned_integer,
    ic_expr_constant_type_signed_integer,
    ic_expr_constant_type_string,
    ic_expr_constant_type_boolean
};

/* a constant
 * either a string or an int
 */
struct ic_expr_constant {
    enum ic_expr_constant_tag tag;
    union {
        long int signed_integer;
        unsigned long int unsigned_integer;
        struct ic_string string;
        unsigned int boolean;
    } u;
};

/* allocate and init a new constant
 * returns pointer on success
 * returns 0 on failure
 */
struct ic_expr_constant *ic_expr_constant_new(enum ic_expr_constant_tag tag);

/* initialise an existing constant
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_constant_init(struct ic_expr_constant *constant, enum ic_expr_constant_tag tag);

/* destroy const
 *
 * will free const if `free_const` is truthy
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_constant_destroy(struct ic_expr_constant *constant, unsigned int free_const);

/* return pointer to unsigned integer within,
 * will only succeed if constant is of the correct type
 *
 * returns pointers on success
 * returns 0 on failure
 */
unsigned long int *ic_expr_constant_get_unsigned_integer(struct ic_expr_constant *constant);

/* return pointer to singed integer within,
 * will only succeed if constant is of the correct type
 *
 * returns pointers on success
 * returns 0 on failure
 */
long int *ic_expr_constant_get_signed_integer(struct ic_expr_constant *constant);

/* return pointer to ic_string within,
 * will only succeed if constant is of the correct type
 *
 * returns pointers on success
 * returns 0 on failure
 */
struct ic_string *ic_expr_constant_get_string(struct ic_expr_constant *constant);

/* return pointer boolean within,
 * will only succeed if constant is of the correct type
 *
 * returns pointers on success
 * returns 0 on failure
 */
unsigned int *ic_expr_constant_get_boolean(struct ic_expr_constant *constant);

/* print this constant */
void ic_expr_constant_print(FILE *fd, struct ic_expr_constant *constant, unsigned int *indent_level);

enum ic_expr_operator_tag {
    ic_expr_operator_type_unary,
    ic_expr_operator_type_binary
};

/* an application of an operator to 2
 * sub expressions
 *
 * maps to a function call
 */
struct ic_expr_operator {
    enum ic_expr_operator_tag tag;

    /* token for the operator */
    struct ic_token *token;

    /* unary operators will only have a first
     * binary operators will have a first and second
     */
    struct ic_expr *first;
    struct ic_expr *second;

    /* the function call that this operator maps to
     * this is populated at analyse level
     */
    struct ic_expr_func_call *fcall;
};

/* allocate and initialise a new unary op
 *
 * returns pointer on success
 * returns 0 on failure
 */
struct ic_expr_operator *ic_expr_operator_new_unary(struct ic_expr *first, struct ic_token *token);

/* initialise an existing unary op
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_operator_init_unary(struct ic_expr_operator *operator, struct ic_expr *first, struct ic_token *token);

/* allocate and initialise a new binary op
 *
 * returns pointer on success
 * returns 0 on failure
 */
struct ic_expr_operator *ic_expr_operator_new_binary(struct ic_expr *first, struct ic_expr *second, struct ic_token *token);

/* initialise an existing binary op
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_operator_init_binary(struct ic_expr_operator *operator, struct ic_expr *first, struct ic_expr *second, struct ic_token *token);

/* initialise an existing op
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_operator_init(struct ic_expr_operator *operator, enum ic_expr_operator_tag tag, struct ic_expr *first, struct ic_expr *second, struct ic_token *token);

/* destroy operator
 *
 * will free op if `free_op` is truthy
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_operator_destroy(struct ic_expr_operator *op, unsigned int free_op);

/* print this operator */
void ic_expr_operator_print(FILE *fd, struct ic_expr_operator *op, unsigned int *indent_level);

struct ic_expr_faccess {
    /* a field access is made up of a left expr and a right identifier
     * a.b
     * foo().c
     *
     * these can be chained
     * foo().a.b.c
     * which would be 3 field access
     *   { { {foo(), a}, b}, c}
     */
    struct ic_expr *left;
    struct ic_expr *right;
};

/* allocate and initialise a field access
 *
 * returns pointer on success
 * returns 0 on failure
 */
struct ic_expr_faccess *ic_expr_faccess_new(struct ic_expr *left, struct ic_expr *right);

/* initialise an existing field access
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_faccess_init(struct ic_expr_faccess *faccess, struct ic_expr *left, struct ic_expr *right);

/* destroy fieldaccess
 *
 * will free op if `free_faccess` is truthy
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_faccess_destroy(struct ic_expr_faccess *faccess, unsigned int free_faccess);

/* print this fieldaccess */
void ic_expr_faccess_print(FILE *fd, struct ic_expr_faccess *faccess, unsigned int *indent_level);

enum ic_expr_tag {
    ic_expr_type_func_call,
    ic_expr_type_identifier,
    ic_expr_type_constant,
    ic_expr_type_operator,
    ic_expr_type_field_access
};

struct ic_expr {
    enum ic_expr_tag tag;
    union {
        struct ic_expr_func_call fcall;
        struct ic_expr_identifier id;
        struct ic_expr_constant cons;
        struct ic_expr_operator op;
        struct ic_expr_faccess faccess;
    } u;
};

/* allocate and initialise a new ic_expr
 * will not initialise union members
 *
 * returns pointer on success
 * returns 0 on failure
 */
struct ic_expr *ic_expr_new(enum ic_expr_tag tag);

/* initialise an existing ic_expr
 * will not initialise union members
 *
 * returns 1 on success
 * returns 0 on failure
 */
int ic_expr_init(struct ic_expr *expr, enum ic_expr_tag tag);

/* takes an existing expr and converts it to a binary operator
 *
 * this will overwrite any data already here
 * make sure you have cloned or zerod the existing data first
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_opify(struct ic_expr *expr, struct ic_expr *first, struct ic_expr *second, struct ic_token *token);

/* takes an existing expr and converts it to a faccess
 *
 * this will overwrite any data already here
 * make sure you have cloned or zerod the existing data first
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_faccessify(struct ic_expr *expr, struct ic_expr *left, struct ic_expr *right);

/* destroy expr
 *
 * will only free expr if `free_expr` is truthy
 *
 * returns 1 on success
 * returns 0 on failure
 */
unsigned int ic_expr_destroy(struct ic_expr *expr, unsigned int free_expr);

/* return pointer to fcall within,
 * will only succeed if expr is of the correct type
 *
 * returns pointers on success
 * returns 0 on failure
 */
struct ic_expr_func_call *ic_expr_get_fcall(struct ic_expr *expr);

/* return pointer to identifier within,
 * will only succeed if expr is of the correct type
 *
 * returns pointers on success
 * returns 0 on failure
 */
struct ic_expr_identifier *ic_expr_get_identifier(struct ic_expr *expr);

/* return pointer to constant within,
 * will only succeed if expr is of the correct type
 *
 * returns pointers on success
 * returns 0 on failure
 */
struct ic_expr_constant *ic_expr_get_constant(struct ic_expr *expr);

/* return pointer to operator within,
 * will only succeed if expr is of the correct type
 *
 * returns pointers on success
 * returns 0 on failure
 */
struct ic_expr_operator *ic_expr_get_operator(struct ic_expr *expr);

/* return pointer to fieldaccess within,
 * will only succeed if expr is of the correct type
 *
 * returns pointers on success
 * returns 0 on failure
 */
struct ic_expr_faccess *ic_expr_get_faccess(struct ic_expr *expr);

/* print this expr */
void ic_expr_print(FILE *fd, struct ic_expr *expr, unsigned int *indent_level);

#endif
