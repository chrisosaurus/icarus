# user defined type with 2 fields, an Int and a String
type Foo
    a::Int
    b::String
end

fn d(i::Int)
    print(i)
end

fn d(s::String)
    print(s)
end

# break apart a Foo and call d on each field
fn d(f::Foo)
    d(f.a)
    d(f.b)
end

# simple function to test return values
fn add_one(i::Int) -> Int
    let tmp = i
    tmp = i + 1
    return tmp
end

fn maybe_add_one(i::Int, b::Bool) -> Int
    # FIXME this doesn't work `if i == 2 and b`
    # due to lack of operator precedence
    if b and i == 2
        i = i + 1
    end

    return i
end

# entry point for program
fn main()
    let f::Foo = Foo(add_one(1) "hello")

    # making up for lack of boolean literals
    f.a = maybe_add_one(f.a, 1 == 1)

    d(f)
end

# hack to work around lack of constructors
builtin fn Foo(a::Int, b::String) -> Foo

